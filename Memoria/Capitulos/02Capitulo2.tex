%---------------------------------------------------------------------
%
%                          Capítulo 2
%
%---------------------------------------------------------------------

\chapter{Estado del arte}

\begin{FraseCelebre}
\begin{Frase}
...
\end{Frase}
\begin{Fuente}
...
\end{Fuente}
\end{FraseCelebre}

\begin{resumen}
	En este capítulo se van a tratar los aspectos más importantes tanto de la computación afectiva como de las diferentes tecnologías y metodologías que se van a utilizar.
	En primer lugar, en la sección 2.1, se define la computación afectiva y sus posibles aplicaciones, también se explican los distintos diccionarios afectivos ya existentes que permiten la marcación emocional de textos. En la sección 2.2 se introduce la tecnología que se va a utilizar para implementar el trabajo, los servicios web. En la sección 2.3 se fijan los conceptos relacionados con la metodología Scrum, la cual hemos seguido durante todo el TFG. En la sección 2.4 se explican las bases de la integración continua aplicada al desarrollo de software y cómo se va a aplicar en este trabajo.

\end{resumen}


%-------------------------------------------------------------------
\section{Computación Afectiva}
%-------------------------------------------------------------------
\label{cap2:sec:computacion_afectiva}

Todo el mundo sabe lo que son las emociones hasta que llega el momento de definirlas. Podríamos definir las emociones como reacciones automáticas que nuestro cuerpo experimenta ante un determinado estímulo. Sin embargo, todas ellas luego derivan en sentimientos más prolongados en el tiempo.

Existen 6 emociones básicas (enfado, miedo, asco, alegría, sorpresa y tristeza), las cuales podemos representar e interpretar gracias a los gestos y movimientos.

La computación afectiva (Picard,1997) es el estudio y el desarrollo de sistemas y dispositivos capaces de percibir, medir e interpretar las emociones humanas.

Esta rama de la computación permite un avance notable en la inteligencia artificial, hasta tal punto que los ordenadores lleguen a adaptarse a los humanos, sus necesidades y estados de ánimo. Los seres humanos están rodeados de emociones, en cualquier ámbito de su vida, tanto de las suyas propias como las de las personas con las que se comunican. Tanta importancia tienen para nosotros que influyen no sólo en nuestra comunicación, sino también en nuestro aprendizaje y toma de decisiones. Por ello, resulta artificial y en ocasiones incluso frustrante intentar comunicarse con una máquina que no es capaz de expresar sentimientos. 

La computación afectiva pretende mejorar la interacción hombre-máquina haciéndola más natural y asequible. 

El funcionamiento de este tipo de sistemas se basa en identificar el estado emocional del sujeto a través de diferentes fuentes (voz, expresiones, señales fisiológicas, palabras...) y procesar la información para clasificarla y aprender de ella. Clasificar la información de entrada puede resultar complicado ya que se suelen recibir varias señales diferentes a la vez, lo que hace necesario utilizar técnicas de priorización para determinar cuáles son las que más aportan a la hora de analizar y gestionar la información. Una vez identificada la emoción predominante, el sistema responde adecuandose a ella. La salida dependerá del tipo de sistema y las herramientas de las que dispone este para expresar su respuesta (colores, sonidos, emoticonos...) En casos más complejos aplicados a robótica o modelado, la salida producida es una simulación de la respuesta que produciría un ser humano ante los estímulos recibidos imitando su expresión corporal, voz o gestos faciales.

La computación afectiva tiene multitud de aplicaciones, ya que como se ha mencionado antes, las emociones están presentes en todos los ámbitos de la vida de una persona. Por lo tanto, puede aplicarse a áreas muy diferentes entre sí como:

\begin{itemize}
	\item \textbf{Marketing}: Actualmente una de sus aplicaciones más explotadas. Poder evaluar la reacción emocional de alguien ante un anuncio o producto es una estrategia comercial que ya está siendo utilizada cada vez por más empresas.
	\item \textbf{Salud}: Principalmente detección del estrés para minimizar sus efectos y aprender a controlarlo. Es posible inferir el nivel de estrés de una persona midiendo sus señales fisiológicas (ritmo cardiaco, respiración...) y si este nivel es demasiado alto se reaccionará en consecuencia según el tipo de sistema. Se puede aplicar de forma similar a las fobias. 
	\item \textbf{Entretenimiento}: La industria de los videojuegos ha crecido mucho en los últimos años e introducir este tipo de tecnología permite a las compañías crear juegos más adaptables y cercanos al jugador, lo que atrae a más público y mejora la experiencia de juego (Ng, Khong, Thwaites, 2012).
	\item \textbf{Robótica}: El mayor problema de los robots diseñados para interactuar con humanos es la carencia de emociones. Algunos de ellos llegan a producir una sensación de incomodidad. Dotar a este tipo de robots de cierta "humanidad" no sólo haría más cómodo el tratar con ellos sino que podrían realizar tareas como el acompañamiento de personas mayores. (Riek, Paul, and Robinson, 2010)
	\item \textbf{Accesibilidad}: Las herramientas que puede generar la computación afectiva pueden servir de gran ayuda a personas que no tengan la capacidad de entender o expresar sus emociones, como por ejemplo personas con autismo. Para este tipo de personas sería extremadamente complicado acceder a la tecnología sin la inclusión de herramientas que les ayuden a detectar el contenido afectivo.
	
\end{itemize}

En este trabajo vamos a centrarnos en el último área, la accesibilidad. En particular, en facilitar a personas que padecen Trastornos del Espectro Autista (TEA) el entendimiento de textos. Trataremos de analizar un texto de entrada para identificar las emociones predominantes y en que medida se presentan, evitando las posibles ambigüedades que pueda haber. Las emociones con las que trataremos son las básicas: alegría, tristeza, miedo, sorpresa y enfado. Una vez identificadas las emociones se etiquetarán para hacerlas más explícitas mediante emoticonos.

Para deducir la emoción que transmite una palabra específica utilizaremos un diccionario afectivo basado en otros ya existentes.

\subsection{Métodos existentes para el marcado de texto emocional}

Los métodos existentes para el marcado de texto emocional podrían clasificarse en cinco categorías básicas: keyword spotting, afinidad léxica, procesamiento estadístico del lenguaje natural, métodos basados en el conocimiento del mundo real y métodos manuales.


\begin{itemize}
	\item \textbf{Keyword spotting}: El marcado del texto se basa en la aparición de palabras emocionales como happy, sad... Un
ejemplo de este método es ANEW (Bradley y Lang, 1999), se trata de una base de datos de 3.109 palabras con su emoción asociada. Las principales desventajas de este método son: problemas cuando la negación está implicada en la frase y dependencia del método en aspectos superficiales cuando en la práctica existen muchas frases cuyo contenido emocional no se encuentra en los adjetivos.
	\item \textbf{Afinidad léxica}: Este método no solo detecta palabras obviamente emocionales como los adjetivos, sino que asigna al resto de palabras una afinidad con las distintas emociones. Este método tiene dos problemas fundamentales: emplea tan solo las palabras sin tener en cuenta el contexto en el que se encuentran por lo que puede fallar con la aparición de las negaciones y ademas este tipo de métodos suelen entrenarse con un corpus lo que dificulta el desarrollo de un modelo reutilizable e independiente del dominio.
	\item \textbf{Procesamiento estadístico}: Consiste en alimentar a un algoritmo de aprendizaje con un amplio corpus de textos marcados emocionalmente. Este método ha sido empleado en el proyecto Webmind (Goertzel et al., 2000).
	\item \textbf{Métodos manuales}: Estos métodos implican el modelado de distintos estado emocionales en términos de modelos afectivos basados en teorías psicológicas sobre las necesidades, los deseos y las metas de los seres humanos. Un ejemplo es el DAYDREAMER (Dyer, 1987)
	\item \textbf{Métodos basados en el conocimiento del mundo real}: Este método no solo mira los aspectos superficiales del texto, sino que va más allá, evalúa la calidad afectiva de la semántica subyacente que contiene el texto. Un ejemplo es el marcador llevado a cabo por Liu, Lieberman y Selker (Liu, Lieberman, y Selker, 2002)

\end{itemize}

Las técnicas basadas en el procesamiento estadístico del lenguaje natural solo funcionan con un texto de entrada lo suficientemente extenso, los métodos manuales precisan un amplio análisis y entendimiento de los textos y hacen muy difícil la generalización y los métodos basados en el conocimiento del "mundo real" necesitan un amplio conocimiento denominado "mundo real". (Francisco, Gervás, 2006)
	
\subsection{Diccionarios Afectivos Existentes}
\label{cap2:subsec:diccionarios}
	
	Un diccionario afectivo es un diccionario en el que las palabras se encuentran marcadas con etiquetas afectivas. Algunos ejemplos de etiquetas afectivas serían: alegría, tristeza, sorpresa, miedo...
	
	En las siguientes secciones presentamos los diccionarios afectivos mas representativos.
	
	\subsubsection{LASSWELL VALUE DICTIONARY Y GENERAL INQUIRER}
	
	Fue a comienzos de los años 60 cuando Stone y Lasswell, ambos investigadores, comenzaron a construir diccionarios en lo que las palabras estaban marcadas con etiquetas afectivas.
	El diccionario Lasswell clasifica sus palabras de manera binaria y en ocho categorías básicas (riqueza, poder, respeto, rectitud, habilidad, iluminación, afecto y bienestar). Además de estas, el esquema de este diccionario distingue entre objetivos sustantivos y los elementos y atributos del proceso de distribución de valores, es decir, evaluación personal y asignación social.
	La clasificación social del contenido mantiene estas distinciones. Las preocupaciones con valores particulares se clasifican en objetivos sustantivos particulares. El esquema de clasificación también distingue varios tipos de transacciones de valor.

\subsubsection{DICCIONARIO DE HATZIVASSILOGLOU Y MCKEOWN}
	
	Este diccionario fue creado en 1997, y tarta de encontrar etiquetas como positive o negative de manera automatizada a través del análisis de un corpus.
	Hatzuvassiloglou y McKeown tomaron una serie de adjetivos que aparecían de manera frecuente y decidieron darles una orientación, empleando un análisis estadístico en el que cuando dos adjetivos aparecían juntos, siguiendo el patrón adjetivo1 y adjetivo 2, devolvía una orientación positiva o negativa. 
	Así, pudieron obtener un diccionario de adjetivos clasificados en positivos y negativos.

\subsubsection{WORDNET AFFECT}

	Se trata de una extensión de WordNet Domains, que incluye un subconjunto de synsets adecuados para representar conceptos afectivos correlacionados con palabras afectivas. De manera similar a nuestro método para etiquetas de dominio, asignamos a una serie de sintonias de WordNet una o mas etiquetas afectivas. En particular, los recursos afectivos que representan el estado emocional son individualizados por sintonizadores marcados por la emocion de la etiqueta A. Tambien existen otras etiquetas para aquellos conceptos que representan estados de animo, situaciones que provocan emociones o respuestas emocionales.
	El recurso se amplió con un conjutno de etiquetas A adicionales (llamadas categorias emocionales), organizadas jerarquicamente, con el fin de especializar sysnsets con una emocion de etiqueta. 
La estructura jerarquica de las nuevas etiquetas a se modelo en la relaciones de hiperonimos de wornet. En una segunda etapa, se definen cuatro etiquetas a-adicionales: positivo, negativo, ambiguo, neutral.
	Otra propiedad importante para el lexico afectico en lo que se se refiere principalmente a la interpretacion adejtivas es la dimension estacionaria/causativa.

	\subsubsection{WHISSELL'S DICTIONARY OF AFFECTA IN LANGUAGE (DAL)}
	
	Este diccionario es un recurso diseñado con el fin de medir el significado emocional de las palabras y textos. El objetivo del diccionario es comparar las palabras con una lista de 8742 palabras que han sido marcadas por distints personas en terminos de las dimensiones activacion y evaluacion e imagenes.

	\subsubsection{DICCIONARIO DE TURNEY Y LITTMAN}
	
	Turney y Littman encontraron una manera mas eficiente para decidir cuando una palabra se podía considerar positiva o negativa. Dado un conjunto de palabras, que previamente ellos conocían como positivas o negativas, probaron como de frecuentemente podía aparecer una palabra en un contexto con un conjunto de palabras positivas o negaticas. 
Empleando la informacion de estudios cercanos y estadísticas clasificaron como positivas todas aquellas palabras que aparecían de forma más significativa con un conjunto de palabras positivas y como negativas aquellas palabras que aparecían con un conjunto de palabras negativas.

\subsubsection{CLAIRVOYANCE AFFECT LEXICON}

	Este diccionario fue desarrollado a mano. Las entradas de este diccionario se dividen en cinco campos: el lema de la palabra, part-of-speech, clase afectiva, centralidad e intensidad.
	
	\subsubsection{ANEW}
	Se trata de un modelo espacial de varias palabras con carga emocional que contribuye a clasificar textos arbitrarios.

%-------------------------------------------------------------------
\section{Servicios Web}
%-------------------------------------------------------------------
\label{cap2:sec:servicios_web}

	Existen múltiples definiciones de servicios web por lo que resulta muy complejo dar una definición de este término. Esta complejidad nos permite hacernos una idea de la cantidad de servicios e implicaciones asociadas que se agrupan bajo este concepto. 
	
	En la actualidad, la definición más general de Servicio Web es la que lo define como un conjunto de aplicaciones o tecnologías capaces de interoperar en la Web. Estas aplicaciones o tecnologías intercambian datos con el fin de ofrecer unos servicios. Los proveedores ofrecen sus servicios como procedimientos remotos y los usuarios solicitan un servicio llamando a estos procedimientos a través de la Web. (www.w3c.es/Divulgación/GuiasBreves/ServiciosWeb)
	
	\subsection{Características de los Servicios Web}	
	\label{cap2:subsec:serviciosweb}
	
	Las características deseable de un Servicio Web son:
	\begin{itemize}
		\item Un servicio que debe poder ser accesible a través de la web. Para ello debe utilizar procotolos de transporte estándares como HTTP, y condificar los mensajes en un lenguaje estándar que pueda conocer cualquier cliente que quiera utilizar el servicio..
		\item Un servicio que debe contener una descripción de sí mismo. De esta forma, una aplicación podrá saber cuál es la función de un determinado servicio web.
		\item Debe poder ser localizo. Deberemos tener algún mecanismo que nos permita encontrar un servicio web que realice una determinada función. De esta forma tendremos la posibilidad de que una aplicación localice el servicio que necesite de forma automática, sin tener que conocerlo previamente el usuario. (http://www.jtech.ua.es/j2ee/publico/servc-web-2012-13/sesion01-apuntes.html)
	\end{itemize}

	
	\subsection{Tipos de Servicios Web}
	\label{cap2:subsec:serviciosweb}
	A nivel técnico, los servicios pueden implementarse de varias formas. En este sentido, podemos distinguir dos tipos de servicios web: los denominados servicios web "grandes", llamados servicios web SOAP, y servicios web RESTful.
	\begin{itemize}
		\item Servicios web SOAP: utilizan mensajes XML para intercomunicarse que siguen el estándar SOAP, un lenguaje XML que define la arquitectura y formato de los mensajes. Dichos sistemas normalmente contienen una descripción legible por la máquina de la descripción de las operaciones ofrecidas por el servicio, escrita en WSDL (lenguaje basado en XML para definir las interfaces sintácticamente).
		\item Servicios web RESTful: utilizan estándares muy conocidos como HTTP, SML, URI, MIME, y tienen una infraestructura "liger" que permite que los servicios se construyan utilizando herramientas de forma mínima. (http://www.jtech.ua.es/j2ee/publico/servc-web-2012-13/sesion01-apuntes.html)
	\end{itemize}
	
	
	\subsection{Arquitectura de los Servicios Web}
	\label{cap2:subsec:serviciosweb}
	
	Los servicios web se componen de varias capas entre las que destacan: servicios de transporte (constituidos por los protocolos de nivel más bajo, que codifican la información independientemente de su formato y que pueden ser comunes a otros servicios), servicios de mensajería, de descripción y de descubrimiento. En las siguiente subsecciones explicaremos más en detalle cada una de estas capas.
	
	\subsubsection{Servicios de transporte}
	
		Capa que se encarga de transportar los mensajes entre aplicaciones. Normalmente se utiliza el protocolo HTTP para este 		transporte. HTTP es el protocolo de nivel de aplicación más utilizado en la red. Define la sintáxis y la semántica utilizada 		para la arquitectura webb. Es utilizado para la transferencia de las transacciones XML a través de la red utilizando los mismos 	principios de HTML.
	
	\subsubsection{Servicios de mensajería}
	
	Capa encargada de la codificación de los mensajes en XML estándar paraa que pueda así ser interpretado en cualquiera de los 	nodos de la red. Puede implementar protocolos como XML-RPC o SOAP.
	
	\begin{itemize}
		\item XML-RPC: Protocolo de llamadas remta que utiliza XML como lenguaje de codificación y HTTP como mecanismo de transporte. Protocolo sencillo, pues solo define algunos tipos de datos y comandos.
		\item SOAP: Protocolo de la capa de aplicación para el intercambio de mensajes basados en XML sobre redes. Es una vía de transmisión entre un SOAP Sender y un SOAP Receiver, pero lo mensajes SOAP deben interactuar con un conjunto de aplicaciones para que se pueda generar un diálogo SOAP.
	\end{itemize}
	
	\subsubsection{Servicios de descripción}
	
	Capa encargada de definir la interfaz pública de un determinad servicio. Esta definición se realiza mediante WSDL, tipo de documento que XML que describe lo que hace un servicio web, dónde se encuentra y la forma de ser invocado.
	
	\subsubsection{Servicios de descubrimiento}
	
	Capa encargada del registro centralizado de servicios, permitiendo que estos sean anunciados y localizados. Para ello se utiliza el protocolo UDDI, el cual define la especificación para construir un directorio distribuido de servicios web, donde los datos se almacenan en XML. Este registro también almacena información sobre las organizaciones que los proporcionan, la categoría en la que se encuentran, y sus instrucciones de uso. 
	
	\subsection{Ventajas e inconvenientes de los servicios web.}
	\label{cap2:subsec:serviciosweb}
	
	Utilizar servicios web puede tener tanto ventajas, como desventajas. A continuación expondremos algunas de ellas.

	\subsubsection{Ventajas}
	\begin{itemize}
		\item Aportan interoperabilidad entre aplicaciones de software independientemente de sus propiedades o de las plataformas sobre las que se instalan.
		\item Fomentan los estándares y protocolos basados en texto, de tal manera que facilitad su comprensión y accesibilidad.
		\item Permiten la combinación e integración de distintos servicios y software independientemente de su ubicación.
		\item  Al apoyarse en HTTP, lo servicios Web se pueden aprovechar de los  de seguridad firewall sin necesidad de cambiar las reglas de filtrado.
		\item Disminuyen el tiempo de desarrollo de las aplicaciones: Pues gracias a la filosofía de orientación a objetos utilizada, el desarrollo se convierte más bien en una labor de composición.
	\end{itemize}
	\subsubsection{Desventajas}
	\begin{itemize}
		\item Bajo rendimiento si se compara con otros modelos de computación distribuida.
		\item Al apoyarse en HTTP, pueden esquivar medidas de seguridad basadas en firewall cuyas reglas tratan de bloquear la comunicación entre programas.
	\end{itemize}
	
	
%-------------------------------------------------------------------
\section{Metodología Scrum}
%-------------------------------------------------------------------
	Scrum es una metodología ágil y flexible para gestionar el desarrollo de software, cuyo principal objetivo es maximizar el retorno de la inversión para su empresa (ROI). Se basa en construir primero la funcionalidad de mayor valor para el cliente y en los principios de inspección continua, adaptación, auto-gestión e innovación.
	
\label{cap2:sec:scrum}

	\subsection{Proceso de desarrollo software}
	\label{cap2:subsec:proceso desarrollo software}
	Un proceso, es un conjunto de actividades, acciones y/o tareas que se realizan para crear un producto determinado; en nuestro caso un producto software.
	
	El proceso de desarrollo software, como estructura general, consta de cinco grandes actividades: \textbf{comunicación}, \textbf{planeación}, \textbf{modelado}, \textbf{construcción} y \textbf{despliegue}. Estas actividades, siempre se realizan en este orden; pero dependiendo del modelo que se emplee variará el flujo; algunos flujos son: lineal, iterativo, evolutivo o paralelo.
	
	El desarrollo de software hace unos años era algo novedoso y tan moderno que no había estrategias claras para crear productos. Por lo que, con motivo de ordenar todo el proceso se crearon diferentes modelos de proceso. Un modelo de proceso no es más que una estructura para realizar las actividades que forman un proceso.
	
	Primeramente, se crean los modelos llamados tradicionales que son procesos muy controlados y con muchas normas y políticas. Se le da mucha importancia a la arquitectura del software y se expresa mediante modelos. El cliente interactúa con el equipo de desarrollo mediante reuniones separadas en el tiempo. En la primera reunión se fija un contrato que el equipo debe seguir, lo que genera muchos problemas a la hora de desarrollar ya que el equipo tomará decisiones sin tener en cuenta lo que el cliente opinaría al respecto. Podríamos decir entonces que es un modelo impuesto externamente no solo por el contrato con el cliente sino porque está basado en normas de estándares. 
	Estos modelos se siguen usando en proyectos con equipos grandes y distribuidos. Generan muchos artefactos y documentación.
	
	Más adelante surgieron los modelos de desarrollo ágiles. 
	La agilidad en términos de software se podría definir como la respuesta efectiva al cambio; pero va más allá, esta idea lleva consigo toda una filosofía determinada en el Manifiesto por el Desarrollo Ágil. Este Manifiesto propone un nuevo modelo de proceso en el que los individuos e interacciones están por encima de los procesos y las herramientas; el software funcionando sobre la documentación extensiva; la colaboración con el cliente sobre la negociación contractual y la respuesta ante el cambio sobre seguir un plan. 

	Dado que los modelos ágiles están diseñados para poder realizar cambios en los requisitos en cualquier momento y están pensados para equipos pequeños, creemos muy conveniente para nuestro trabajo usar una metodología ágil.
	
	\subsection{SCRUM}
	\label{cap2:subsec:SCRUM}
	
	SCRUM es una metodología ágil para gestionar el desarrollo de software. Fue definido por \textit{Ikujiro Nonaka} e \textit{Hirotaka Takeuchi} a principios de los 80; compararon la forma de trabajo con el avance en formación de scrum (melé en español) de los jugadores de rugby y por esta razón se llama la metodología SCRUM. \textit{Nonaka} y \textit{Takeuchi} caracterizan SCRUM por el protagonismo de equipos brillantes, auto-organizados y motivados que abordan el desarrollo de sistemas complejos partiendo de una visión general y solapando las fases del desarrollo.
	
	SCRUM divide el trabajo en diferentes unidades llamadas \textsl{sprints},  estos tienen una duración preestablecida de entre dos y cuatro semanas obteniendo siempre al final una versión del software con nuevas prestaciones listas para ser usadas. En cada \textsl{sprint} se ajusta la funcionalidad y se añaden nuevas prestaciones priorizando aquellas que aporten más valor. 
	
	\subsubsection{Roles}
	
	Los roles identificados por Scrum son:
	
	\begin{itemize}
		\item \textbf{Product Owner}: Presenta al cliente. Se encarga de definir los objetivos y de dar valor al producto.
		\item \textbf{Scrum Master}: Encargado de asegurar que se cumplen las buenas prácticas y valores descritos en el modelo Scrum.
		\item \textbf{Scrum Team}: Equipo encargado de desarrollar y entregar el producto. Es autogestionado y multidisciplinar.
	\end{itemize}
	
	\subsubsection{Artefactos}
	
	Los artefactos definidos en Scrum son:
	
	
	\begin{itemize}
		\item \textbf{Product backlog}: Lista realizada por el Product Owner que contiene los requisitos del producto, ordenados por prioridad. A lo largo del desarrollo crece y evoluciona. En Scrum los requisitos se definen mediante historias de usuarios. Una historia de usuario es la escripción de una funcionalidad que debe incorporar un sistema de software, y cuya implementación aporta valor al cliente.
		\item \textbf{Sprint backlog}: Lista de las tareas que debe realizar el equipo durante el sprint. 
	\end{itemize}
	
	\subsubsection{Eventos}
	Por último, Scrum también define una serie de eventos
	
	
	\begin{itemize}
		\item \textbf{Sprint}: Cada una de las iteraciones del desarrollo.
		\item \textbf{Sprint planning}: Se trata de la planificación del spring. Este evento consta de dos partes en las cuales participan el Product Owner y el equipo. En la primera parte el Producto Owner presenta lo que quiere que se haga y resuelve dudas; en la segunda parte el equipo estima y deciden hasta donde van a llegar, para posteriormente crear el Sprint Backlog.
		\item \textbf{Dialy sprint meeting}: Reunión diaria como máximo de quince minutos, de pie, en donde cada componente del equipo informa sobre cómo va en sus tareas, lo que hizo el día anterior, lo que hará ese día y los problemas que ha encontrado o los que cree que se va a encontrar.
		\item \textbf{Sprint Review}: Reunión que se realiza al concluir el sprint centrándose en el producto. Se presenta el producto creado en el sprint al Product Owner y este lo analiza.
		\item \textbf{Sprint Retrospective}: Reunión donde se habla de cómo ha funcionado el equipo en el sprint y qué cosas se pueden mejorar para el siguiente a nivel de proceso o metodología. En esta reunión participa todo el Scrum team y Scrum Máster. Se centra en la metodología.
	\end{itemize}
	
	
	%\figura{Bitmap/Capitulo2/scrum}{width=.5\textwidth}{fig:scrum}%{Flujo de la metodología SCRUM.}
	\figura{Bitmap/Capitulo2/scrum}{width=.9\textwidth}{fig:scrum}{Flujo SCRUM} 
	
	En la Figura \ref{fig:scrum} podemos ver un diagrama del flujo SCRUM. Sería el siguiente: el Product Owner crea el Product backlog con los requisitos y características por orden de prioridades. A continuación, en un Sprint planning, se presenta el product backlog y se decide qué actividades van a desarrollar y cuánto tiempo van a tardar. Después de esta reunión se elabora el Sprint Backlog con todas las actividades que van a realizar divididas en tareas; cada componente del grupo se asigna una tarea y en cuanto acabe seguirá con la siguiente actividad que no esté hecha. Es muy importatne el orden de las tareas ya que, el cliente ha ordenado en el product backlog las actividades por prioridad y el equipo desarrollará estas siguiendo dicho parámetro. A continuación se comienza el sprint con el tiempo establecido. Este tiempo no se puede cambiar ni el equipo que está trabajando. Cada día, el equipo se reunirá en una Dialy sprint meeting para poner en común lo explicado anteriormente. Al final del sprint se realiza la Sprint Review donde se entrega el incremento o el producto hasta el momento al cliente; por lo tanto en esta reunión están presentes el Scrum team, el Scrum master y el Product Owner. Por último el Scrum team junto con el Scrum master se vuelve a reunir para hacer el Sprint Retrospective.
	

%-------------------------------------------------------------------
\section{Integracion Continua}
%-------------------------------------------------------------------
\label{cap2:sec:integracion}

La práctica de desarrollo de software que se va a utilizar en el desarrollo de este trabajo es la integración continua. Se basa en que los desarrolladores combinen todos los cambios que realicen en el código en un repositorio común de forma periódica, de tal forma que una vez subidos estos cambios, se ejecutan una serie de pruebas automáticas sobre estos con el fin de validarlos. Aparte de las pruebas automáticas se realizan pruebas manuales para buscar errores más difíciles de encontrar. Hasta que las pruebas sobre el nuevo código no acaban no se puede continuar. Aplicando esto a la metodología Scrum que vamos a utilizar, una historia de usuario no se puede considerar acabada hasta que no pase todas las pruebas, tanto automáticas como manuales.

Las principales ventajas de la integración continua:

\begin{itemize}
	\item \textbf{Detección de errores:} Cada vez que el código cambia se compila y se somete a pruebas para garantizar que no hay errores. Este proceso aumenta la calidad del software y minimiza los riesgos del proceso ya que se tiene control sobre las versiones en todo momento. Cuanto más se tarde en detectar un error más trabajo llevará arreglarlo.
	\item \textbf{Visibilidad del proceso:} Todos los pasos que se realizan en el desarrollo son visibles a todo el equipo, que tiene una estrategia común muy bien definida.
	\item \textbf{Mejora del equipo:} Los desarrolladores no solo tienen una visión muy clara y estructurada del proceso sino que también aprenden a realizar todo tipo de pruebas, lo que les hace mejorar a nivel profesional. 
\end{itemize}

Lo primero para poder utilizar integración continua es tener definido un pipeline, es decir, un conjunto de fases por las que tiene que pasar el software y que están automatizadas. Se establecen criterios para que el código pase de una fase a otra y estrategias para gestionar errores que puedas surgir en las diferentes fases (control de versiones). Es importante tener bien definidas las pruebas que se van a realizar sobre cada fase y que estas puedan garantizar la máxima corrección posible sin tardar más de lo admisible, ya que se necesita un feedback rápido para poder seguir avanzando en el proceso. Cada fase es un grupo de pruebas y cada subida de código es un pipeline distinto que avanza de forma independiente por las fases. Por lo tanto se sabe en todo momento en qué punto se encuentra una versión específica. Esto permite tener una visión general de todo el proceso facilitando notablemente la detección de errores en fases y pipelines concretos.

Para el correcto funcionamiento de esta práctica tiene que haber pequeñas integraciones de forma frecuente, una vez al día por ejemplo. Cuantos menos cambios haya más fácil es la integración en el producto general y solucionar los posibles errores que esta pueda generar. Cabe destacar que aunque una parte de código funcione de forma independiente no implica que vaya a funcionar al integrarlo en un programa más grande, por ello cuanto más frecuentes sean las integraciones mejor. 

En nuestro caso la integración continua se aplicará de la siguiente manera:

\begin{itemize}
	\item \textbf{Repositorio:} Se utilizará un repositorio común de \textit{GitHub} en el que se subirán todos los cambios realizados en el código. Al ser un equipo de desarrollo pequeño y estar utilizando la metodología Scrum en principio todos los miembros del equipo estarán trabajando en la misma rama. Esto puede llegar a bloquear el proceso mientras una versión acabe de pasar las pruebas.
	\item \textbf{Jenkins:} Tendremos Jenkins corriendo en un servidor para realizar las pruebas automáticas. Cada vez que se detecten cambios en el repositorio este avisará al servidor que procederá a hacer las pruebas de compilación y funcionamiento sobre el nuevo código.
	\item \textbf{Pruebas manuales:} Algún miembro del equipo realizará las tareas de "`tester"'. Después de las pruebas automáticas se realizará otra serie de pruebas planificadas de antemano para probar mejor la funcionalidad del código. El "`tester"' no será siempre la misma persona.
		\item \textbf{Pruebas automáticas:} Usaremos un software especial con el fin de controlar la ejecución de pruebas y la comparación entre los resultados obtenidos y los resultados esperados. El uso de estas pruebas, nos permite incluir pruebas muy repetitivas y necesarias, dado que habrá pruebas que realizarlas de manera manual nos podrá ser muy costoso.
\end{itemize}




% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
